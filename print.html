<!DOCTYPE HTML>
<html lang="es" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lenguajes de Programacion y Metodos de Traduccion I</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introducción</a></li><li class="chapter-item expanded affix "><li class="part-title">Unidad 1</li><li class="chapter-item expanded "><a href="U1/index.html"><strong aria-hidden="true">1.</strong> Lenguajes, Lenguajes regulares y expresiones regulares</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="U1/U1S1/index.html"><strong aria-hidden="true">1.1.</strong> Compilador</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="U1/U1S1/t1.html"><strong aria-hidden="true">1.1.1.</strong> Introducción a los compiladores</a></li><li class="chapter-item expanded "><a href="U1/U1S1/compilador/compilador.html"><strong aria-hidden="true">1.1.2.</strong> Compilador: Conceptos Básicos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="U1/U1S1/compilador/analisis/index.html"><strong aria-hidden="true">1.1.2.1.</strong> Fase de Análisis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="U1/U1S1/compilador/analisis/analisis_lexico.html"><strong aria-hidden="true">1.1.2.1.1.</strong> Análisis Léxico</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.2.1.2.</strong> Análisis Sintáctico</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.2.1.3.</strong> Análisis Semántico</div></li></ol></li><li class="chapter-item expanded "><a href="U1/U1S1/compilador/sintesis/index.html"><strong aria-hidden="true">1.1.2.2.</strong> Fase de Síntesis</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.2.2.1.</strong> Generación de Código Intermedio</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.2.2.2.</strong> Optimización de Código</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.2.2.3.</strong> Generación de Código Objeto</div></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="U1/U1S2/elementos_basicos.html"><strong aria-hidden="true">1.2.</strong> Elementos Básicos de los Lenguajes Formales: Alfabetos, Cadenas y Lenguajes</a></li><li class="chapter-item expanded "><a href="U1/U1S3/Introduccion.html"><strong aria-hidden="true">1.3.</strong> Lenguaje regular</a></li><li class="chapter-item expanded "><a href="U1/U1S4/index.html"><strong aria-hidden="true">1.4.</strong> Expresiones regulares para tokens</a></li><li class="chapter-item expanded "><a href="U1/U1S5/index.html"><strong aria-hidden="true">1.5.</strong> Autómatas finitos deterministas (DFA)</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Unidad 2</li><li class="chapter-item expanded "><a href="U2/index.html"><strong aria-hidden="true">2.</strong> Autómatas deterministas y autómatas no deterministas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="U2/U2S6.html"><strong aria-hidden="true">2.1.</strong> Definición de un Autómata Finito no determinista (NFA)</a></li><li class="chapter-item expanded "><a href="U2/U2S7.html"><strong aria-hidden="true">2.2.</strong> Ejemplos de relación de expresiones regulares y autómatas</a></li><li class="chapter-item expanded "><a href="U2/U2S8.html"><strong aria-hidden="true">2.3.</strong> Teorema de Kleene</a></li><li class="chapter-item expanded "><a href="U2/U2S9.html"><strong aria-hidden="true">2.4.</strong> Teorema de conversión de AF no determinista en determinista</a></li><li class="chapter-item expanded "><a href="U2/U2S10.html"><strong aria-hidden="true">2.5.</strong> Conversión de AF no determinista en determinístico</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Unidad 3</li><li class="chapter-item expanded "><a href="U3/index.html"><strong aria-hidden="true">3.</strong> Manejo de la herramienta Flex</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="U3/U3S11.html"><strong aria-hidden="true">3.1.</strong> FLEX: herramienta para generar analizadores léxicos</a></li><li class="chapter-item expanded "><a href="U3/U3S12.html"><strong aria-hidden="true">3.2.</strong> Formato de un archivo de entrada de FLEX</a></li><li class="chapter-item expanded "><a href="U3/U3S13.html"><strong aria-hidden="true">3.3.</strong> Uso del FLEX para diversas tareas</a></li><li class="chapter-item expanded "><a href="U3/U3S14.html"><strong aria-hidden="true">3.4.</strong> Utilización del FLEX para otras tareas</a></li><li class="chapter-item expanded "><a href="U3/U3S15.html"><strong aria-hidden="true">3.5.</strong> Uso del Flex para generar un analizador léxico</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Unidad 4</li><li class="chapter-item expanded "><a href="U4/index.html"><strong aria-hidden="true">4.</strong> Definición formal de una gramática</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="U4/U4S16.html"><strong aria-hidden="true">4.1.</strong> Máquinas de Estados Finitos</a></li><li class="chapter-item expanded "><a href="U4/U4S17.html"><strong aria-hidden="true">4.2.</strong> Máquina de estado finito para aplicaciones</a></li><li class="chapter-item expanded "><a href="U4/U4S18.html"><strong aria-hidden="true">4.3.</strong> Evaluación final individual</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Bibliografía</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Contribuidores</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lenguajes de Programacion y Metodos de Traduccion I</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Leo-Spj/mdBook-TLPMT1" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="teoria-de-lenguajes-de-programacion-y-metodos-de-traduccion-i"><a class="header" href="#teoria-de-lenguajes-de-programacion-y-metodos-de-traduccion-i">Teoria de Lenguajes de Programacion y Metodos de Traduccion I</a></h1>
<p>Este material está diseñado para proporcionar a los estudiantes las bases necesarias para analizar, diseñar e implementar la fase de Analizador Léxico de un Compilador, de acuerdo con las exigencias del entorno empresarial.</p>
<h2 id="fundamentación"><a class="header" href="#fundamentación">Fundamentación</a></h2>
<p>El curso se centra en establecer los fundamentos esenciales que capacitarán al estudiante para abordar la fase del Analizador Léxico de un Compilador. Se explorarán temas clave como Lenguajes, Lenguajes regulares y expresiones regulares, Autómatas deterministas y no deterministas, el manejo de la herramienta Flex, y finalmente, la definición formal de una gramática.</p>
<h2 id="sumilla"><a class="header" href="#sumilla">Sumilla</a></h2>
<p>Este curso, de naturaleza teórica, aborda los siguientes temas:</p>
<ul>
<li>Lenguajes, Lenguajes regulares y expresiones regulares.</li>
<li>Autómatas deterministas y no deterministas.</li>
<li>Manejo de la herramienta Flex.</li>
<li>Definición formal de una gramática.</li>
</ul>
<h2 id="logro-general-de-aprendizaje"><a class="header" href="#logro-general-de-aprendizaje">Logro General de Aprendizaje</a></h2>
<p>Al término del curso, los estudiantes serán capaces de utilizar las reglas gramaticales para determinar el orden de las cadenas mediante la herramienta Flex.</p>
<h2 id="unidades-y-logros-específicos-de-aprendizaje"><a class="header" href="#unidades-y-logros-específicos-de-aprendizaje">Unidades y Logros Específicos de Aprendizaje</a></h2>
<h3 id="unidad-de-aprendizaje-1-lenguajes-lenguajes-regulares-y-expresiones-regulares"><a class="header" href="#unidad-de-aprendizaje-1-lenguajes-lenguajes-regulares-y-expresiones-regulares">Unidad de Aprendizaje 1: Lenguajes, Lenguajes regulares y expresiones regulares</a></h3>
<p>En esta unidad, los estudiantes desarrollarán habilidades para formar unidades lógicas llamadas Tokens, leyendo los caracteres de un programa de un lenguaje de programación mediante expresiones regulares.</p>
<h3 id="unidad-de-aprendizaje-2-autómatas-deterministas-y-no-deterministas"><a class="header" href="#unidad-de-aprendizaje-2-autómatas-deterministas-y-no-deterministas">Unidad de Aprendizaje 2: Autómatas deterministas y no deterministas</a></h3>
<p>Los estudiantes aprenderán a describir procesos para el reconocimiento de patrones de cadenas para formar los Tokens de un lenguaje de programación.</p>
<h3 id="unidad-de-aprendizaje-3-manejo-de-la-herramienta-flex"><a class="header" href="#unidad-de-aprendizaje-3-manejo-de-la-herramienta-flex">Unidad de Aprendizaje 3: Manejo de la herramienta Flex</a></h3>
<p>En esta unidad, los estudiantes realizarán el análisis léxico sobre cada frase de un programa de un lenguaje de programación con los Tokens provenientes del analizador léxico.</p>
<h3 id="unidad-de-aprendizaje-4-definición-formal-de-una-gramática"><a class="header" href="#unidad-de-aprendizaje-4-definición-formal-de-una-gramática">Unidad de Aprendizaje 4: Definición formal de una gramática</a></h3>
<p>Los estudiantes utilizarán las reglas gramaticales que determinan el orden en que deben ir las cadenas aceptadas en un determinado lenguaje.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="resumen-de-unidad-1"><a class="header" href="#resumen-de-unidad-1">Resumen de Unidad 1</a></h2>
<h1 id="compiladores-y-lenguajes-formales"><a class="header" href="#compiladores-y-lenguajes-formales">Compiladores y Lenguajes Formales</a></h1>
<h2 id="compiladores-y-lenguajes-de-programación"><a class="header" href="#compiladores-y-lenguajes-de-programación">Compiladores y Lenguajes de Programación</a></h2>
<p>En esta sección, se abordan los fundamentos esenciales relacionados con los compiladores y los lenguajes de programación. Se examina el papel de los traductores, incluyendo tanto intérpretes como compiladores, en la transformación del código fuente en código ejecutable. Asimismo, se proporciona una exposición detallada sobre la función y la importancia de los compiladores en el proceso de traducción.</p>
<h2 id="análisis-léxico-y-procesamiento-de-cadenas"><a class="header" href="#análisis-léxico-y-procesamiento-de-cadenas">Análisis Léxico y Procesamiento de Cadenas</a></h2>
<p>El análisis léxico se presenta como la etapa inicial y fundamental en el proceso de traducción. Se discuten los aspectos clave de esta fase, que incluyen la lectura del código fuente y las funciones del analizador léxico. Además, se exploran los conceptos de componentes léxicos, como lexemas y tokens, y se examina el proceso de reconocimiento de estos componentes para generar tokens en un lenguaje de programación.</p>
<h2 id="lenguajes-formales-y-expresiones-regulares"><a class="header" href="#lenguajes-formales-y-expresiones-regulares">Lenguajes Formales y Expresiones Regulares</a></h2>
<p>En esta sección, se introduce el concepto de lenguaje simbólico y se exploran sus componentes básicos, como la concatenación, la potencia y las cerraduras en conjuntos y cadenas. Se define el concepto de lenguaje, así como las operaciones fundamentales entre lenguajes. Además, se profundiza en el uso de expresiones regulares como herramientas para describir patrones en cadenas de texto, incluyendo las operaciones y extensiones asociadas.</p>
<h2 id="expresiones-regulares-para-tokens-de-lenguajes-de-programación"><a class="header" href="#expresiones-regulares-para-tokens-de-lenguajes-de-programación">Expresiones Regulares para Tokens de Lenguajes de Programación</a></h2>
<p>Se analiza el uso específico de expresiones regulares en la identificación de tokens en lenguajes de programación. Se categorizan los tokens, como palabras reservadas, símbolos especiales, identificadores y literales, y se presentan ejemplos de expresiones regulares para reconocer números enteros y reales, así como identificadores y tokens específicos de un lenguaje.</p>
<h2 id="autómatas-y-reconocimiento-de-lenguajes"><a class="header" href="#autómatas-y-reconocimiento-de-lenguajes">Autómatas y Reconocimiento de Lenguajes</a></h2>
<p>Finalmente, se introduce el concepto de autómatas finitos deterministas (DFA) como herramientas para el reconocimiento de lenguajes. Se analizan los componentes esenciales de un DFA, incluyendo estados, estado inicial y estados finales, así como su representación mediante tabla y diagrama. Además, se explora el concepto de lenguaje reconocido por un autómata finito determinista.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamentos-de-compiladores-y-lenguajes-de-programación"><a class="header" href="#fundamentos-de-compiladores-y-lenguajes-de-programación">Fundamentos de compiladores y lenguajes de Programación</a></h1>
<h3 id="generación-de-lenguajes-de-programación"><a class="header" href="#generación-de-lenguajes-de-programación">Generación de Lenguajes de Programación</a></h3>
<p>La generación de lenguajes de programación es un área de estudio en la teoría de lenguajes de programación que se centra en la creación de nuevos lenguajes de programación y en la mejora de los existentes.</p>
<h3 id="por-qué-generar-nuevos-lenguajes-de-programación"><a class="header" href="#por-qué-generar-nuevos-lenguajes-de-programación">¿Por qué Generar Nuevos Lenguajes de Programación?</a></h3>
<p>Aunque ya existen muchos lenguajes de programación, la generación de nuevos lenguajes puede ser necesaria para satisfacer necesidades específicas, como mejorar la eficiencia, facilitar ciertos tipos de programación, o proporcionar nuevas formas de abstracción.</p>
<h3 id="diseño-de-lenguajes-de-programación"><a class="header" href="#diseño-de-lenguajes-de-programación">Diseño de Lenguajes de Programación</a></h3>
<p>El diseño de un nuevo lenguaje de programación implica tomar decisiones sobre su sintaxis, semántica y características de tipo. Esto puede incluir la elección entre un enfoque imperativo o funcional, la definición de la estructura de los programas y la determinación de cómo se manejarán los errores.</p>
<h3 id="implementación-de-lenguajes-de-programación"><a class="header" href="#implementación-de-lenguajes-de-programación">Implementación de Lenguajes de Programación</a></h3>
<p>Una vez diseñado el lenguaje, el siguiente paso es implementarlo. Esto implica la creación de un compilador o intérprete que pueda traducir programas escritos en el nuevo lenguaje a un formato que pueda ser ejecutado por una máquina.</p>
<h3 id="herramientas-para-la-generación-de-lenguajes-de-programación"><a class="header" href="#herramientas-para-la-generación-de-lenguajes-de-programación">Herramientas para la Generación de Lenguajes de Programación</a></h3>
<p>Existen varias herramientas que pueden ayudar en la generación de lenguajes de programación, como los generadores de analizadores léxicos y sintácticos. Estas herramientas pueden automatizar partes del proceso de implementación del lenguaje.</p>
<h3 id="ojo"><a class="header" href="#ojo">Ojo</a></h3>
<p>La generación de lenguajes de programación es un campo importante y en constante evolución en la teoría de lenguajes de programación. A través de la generación de nuevos lenguajes, los programadores pueden continuar empujando los límites de lo que es posible en la programación.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducción-a-los-compiladores"><a class="header" href="#introducción-a-los-compiladores">Introducción a los compiladores</a></h1>
<h2 id="fases-de-un-compilador"><a class="header" href="#fases-de-un-compilador">Fases de un Compilador</a></h2>
<p>Un compilador es una herramienta fundamental en el proceso de transformar un programa escrito en un lenguaje de alto nivel en código ejecutable por una computadora. Este proceso se divide en varias etapas que conforman las fases del compilador. A continuación, se detallan estas fases y su importancia en el proceso de compilación:</p>
<p><img src="U1/U1S1/./FasesdeunCompilador.png" alt="Fases de un Compilador" />
El diagrama muestra las fases de un compilador, que son los pasos que se siguen para transformar un programa fuente en un programa objeto.</p>
<h3 id="programa-fuente"><a class="header" href="#programa-fuente">Programa Fuente</a></h3>
<p>El programa fuente es el punto de partida del proceso de compilación. Consiste en el código escrito por el programador en un lenguaje de alto nivel, como C++, Java o Python.</p>
<h3 id="administrador-de-la-tabla-de-símbolos"><a class="header" href="#administrador-de-la-tabla-de-símbolos">Administrador de la Tabla de Símbolos</a></h3>
<p>Durante el análisis del programa fuente, se encuentran diversos símbolos, como variables, constantes y funciones. El administrador de la tabla de símbolos se encarga de almacenar esta información para su posterior uso en etapas posteriores del compilador.</p>
<ol>
<li>
<h3 id="analizador-léxico"><a class="header" href="#analizador-léxico">Analizador Léxico</a></h3>
</li>
</ol>
<p>La primera fase del compilador es el análisis léxico. Aquí, el programa fuente se divide en unidades léxicas llamadas tokens, que representan los elementos básicos del lenguaje de programación, como palabras clave, identificadores, operadores y símbolos.</p>
<ol start="2">
<li>
<h3 id="analizador-sintáctico"><a class="header" href="#analizador-sintáctico">Analizador Sintáctico</a></h3>
</li>
</ol>
<p>El analizador sintáctico toma la secuencia de tokens generada por el analizador léxico y verifica que siga las reglas gramaticales del lenguaje de programación. Esto garantiza que la estructura del programa sea correcta desde el punto de vista sintáctico.</p>
<ol start="3">
<li>
<h3 id="analizador-semántico"><a class="header" href="#analizador-semántico">Analizador Semántico</a></h3>
</li>
</ol>
<p>Una vez que la estructura sintáctica del programa se ha validado, entra en juego el analizador semántico. Este componente verifica que el programa tenga sentido desde un punto de vista semántico. Por ejemplo, se asegura de que las variables estén declaradas antes de ser utilizadas y que los tipos de datos sean compatibles en las operaciones.</p>
<ol start="4">
<li>
<h3 id="generador-de-código-intermedio"><a class="header" href="#generador-de-código-intermedio">Generador de Código Intermedio</a></h3>
</li>
</ol>
<p>El generador de código intermedio transforma el programa fuente en una representación intermedia, más abstracta y fácil de manipular. Esta etapa facilita la optimización del código y la generación del código objeto final.</p>
<ol start="5">
<li>
<h3 id="optimizador-de-código"><a class="header" href="#optimizador-de-código">Optimizador de Código</a></h3>
</li>
</ol>
<p>El optimizador de código mejora la representación intermedia del programa para hacerlo más eficiente en términos de tiempo de ejecución y consumo de recursos.</p>
<ol start="6">
<li>
<h3 id="generador-de-código-objeto"><a class="header" href="#generador-de-código-objeto">Generador de Código Objeto</a></h3>
</li>
</ol>
<p>Finalmente, el generador de código objeto traduce la representación intermedia del programa en código objeto, que es un conjunto de instrucciones ejecutables por la máquina objetivo.</p>
<h3 id="manejador-de-errores"><a class="header" href="#manejador-de-errores">Manejador de Errores</a></h3>
<p>Durante todo el proceso de compilación, es posible que se encuentren errores léxicos, sintácticos o semánticos en el programa fuente. El manejador de errores se encarga de identificar, reportar y gestionar estos errores de manera adecuada.</p>
<h3 id="programa-objeto"><a class="header" href="#programa-objeto">Programa Objeto</a></h3>
<p>El resultado final del proceso de compilación es el programa objeto, que consiste en el código ejecutable generado a partir del programa fuente. Este programa objeto puede ser ejecutado directamente por la máquina objetivo.</p>
<h2 id="conocimientos-adicionales"><a class="header" href="#conocimientos-adicionales">Conocimientos Adicionales</a></h2>
<h3 id="código-fuente"><a class="header" href="#código-fuente">Código Fuente</a></h3>
<p>El código fuente es el conjunto de instrucciones y declaraciones escritas en el lenguaje de programación que los desarrolladores utilizan para crear programas y aplicaciones. Este código es legible y comprensible para los humanos. Los programadores escriben el código fuente utilizando un editor de texto o un entorno de desarrollo integrado (IDE). El código fuente debe ser compilado o interpretado para convertirlo en un formato que la computadora pueda ejecutar.</p>
<h3 id="bytecode"><a class="header" href="#bytecode">Bytecode</a></h3>
<p>El bytecode es un tipo de código que ha sido traducido desde el código fuente a un formato de bajo nivel que es más fácil para una máquina virtual ejecutar. No es código de máquina (que sería específico para un tipo de hardware), sino un paso intermedio entre el código fuente y el código de máquina.</p>
<p>El bytecode es típicamente utilizado en lenguajes de programación como Java y Python. En Java, por ejemplo, el compilador javac traduce el código fuente a bytecode, que luego puede ser ejecutado en cualquier máquina que tenga instalada la Máquina Virtual de Java (JVM), independientemente del sistema operativo o la arquitectura de hardware subyacente.</p>
<h2 id="si-no-existieran-los-compiladores-traductores-e-intérpretes"><a class="header" href="#si-no-existieran-los-compiladores-traductores-e-intérpretes">Si no existieran los compiladores, traductores e intérpretes</a></h2>
<p>Si no existieran los compiladores, traductores e intérpretes, los programadores tendrían que escribir código directamente en lenguaje de máquina, que es una tarea muy compleja y propensa a errores. El lenguaje de máquina es específico para cada tipo de hardware, por lo que los programadores tendrían que escribir diferentes versiones de su código para cada tipo de computadora.</p>
<p>Además, sin los compiladores e intérpretes, los lenguajes de programación de alto nivel como Python, Java, C++, entre otros, no existirían. Estos lenguajes son más fáciles de aprender y usar que el lenguaje de máquina, y permiten a los programadores escribir código de manera más eficiente y con menos errores.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilador-conceptos-básicos"><a class="header" href="#compilador-conceptos-básicos">Compilador: Conceptos Básicos</a></h1>
<h2 id="compilar-y-compilador"><a class="header" href="#compilar-y-compilador">Compilar y Compilador</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Compilar</th><th>Compilador</th></tr></thead><tbody>
<tr><td><strong>Definición:</strong> La compilación es el proceso de transformar un programa fuente en un programa objeto ejecutable.</td><td><strong>Definición:</strong> Un compilador es una herramienta que se utiliza para traducir un programa fuente escrito en un lenguaje de alto nivel a un programa objeto ejecutable, puede ser en <code>binario</code> o en <code>código intermedio como el bytecode</code>.</td></tr>
<tr><td><strong>Objetivo:</strong> El objetivo de la compilación es generar un programa ejecutable a partir del código fuente.</td><td><strong>Objetivo:</strong> El objetivo de un compilador es generar un programa ejecutable a partir del código fuente.</td></tr>
<tr><td><strong>Resultado:</strong> El resultado de la compilación es un programa objeto que puede ser ejecutado por la máquina objetivo.</td><td><strong>Funcionamiento:</strong> Un compilador consta de varias etapas, como el análisis léxico, sintáctico, semántico, la generación de código intermedio y la optimización de código.</td></tr>
<tr><td><strong>Pasos:</strong> La compilación consta de varias etapas, como el análisis léxico, sintáctico, semántico, la generación de código intermedio y la optimización de código.</td><td><strong>Tipos:</strong> Existen diferentes tipos de compiladores, como los compiladores de una sola pasada, los compiladores de múltiples pasadas, los compiladores de optimización, etc.</td></tr>
<tr><td><strong>Herramientas:</strong> Para compilar un programa, se utiliza un compilador específico para el lenguaje de programación en el que está escrito el programa.</td><td><strong>Ejemplos:</strong> Algunos ejemplos de compiladores populares son GCC (GNU Compiler Collection), Clang, Visual C++, etc.</td></tr>
</tbody></table>
</div>
<h2 id="diferencias-entre-compilador-e-intérprete"><a class="header" href="#diferencias-entre-compilador-e-intérprete">Diferencias entre compilador e intérprete</a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Diferencias</strong></th><th><strong>Compilador</strong></th><th><strong>Intérprete</strong></th></tr></thead><tbody>
<tr><td><strong>Proceso</strong></td><td>El compilador traduce todo el programa a código máquina antes de ejecutarlo.</td><td>El intérprete traduce y ejecuta el programa línea por línea en tiempo real.</td></tr>
<tr><td><strong>Ejecución</strong></td><td>El programa compilado se ejecuta más rápido ya que no necesita realizar la traducción en tiempo real.</td><td>El programa interpretado puede ser más lento ya que realiza la traducción en tiempo real durante la ejecución.</td></tr>
<tr><td><strong>Dependencias</strong></td><td>El programa compilado no depende del compilador una vez que se ha generado el programa objeto.</td><td>El programa interpretado depende del intérprete para su ejecución.</td></tr>
<tr><td><strong>Portabilidad</strong></td><td>El programa compilado puede ser ejecutado en cualquier máquina compatible con la arquitectura del programa objeto.</td><td>El programa interpretado puede requerir un intérprete específico para cada plataforma en la que se desee ejecutar.</td></tr>
<tr><td><strong>Errores</strong></td><td>Los errores de compilación se detectan antes de la ejecución del programa.</td><td>Los errores de interpretación se detectan durante la ejecución del programa.</td></tr>
<tr><td><strong>Modificaciones</strong></td><td>Para realizar cambios en el programa, es necesario recompilarlo.</td><td>Los cambios en el programa pueden realizarse directamente sin necesidad de recompilarlo.</td></tr>
<tr><td><strong>Ejemplos de Lenguajes</strong></td><td>C, C++, Java, etc.</td><td>Python, Ruby, JavaScript, etc.</td></tr>
</tbody></table>
</div>
<h2 id="estructura-de-un-compilador"><a class="header" href="#estructura-de-un-compilador">Estructura de un compilador</a></h2>
<p>De manera general el proceso de compilacion consta de 2 fases principales:</p>
<ol>
<li>
<p><strong>Análisis:</strong> En esta fase, el compilador analiza el código fuente para identificar la estructura del programa y generar una representación intermedia del mismo. Esta fase se divide en tres subfases: análisis léxico, análisis sintáctico y análisis semántico.</p>
</li>
<li>
<p><strong>Síntesis:</strong> En esta fase, el compilador genera el código objeto a partir de la representación intermedia generada en la fase de análisis. Esta fase también puede incluir la optimización del código generado.</p>
</li>
</ol>
<h2 id="ventajas-y-desventajas-de-la-compilación"><a class="header" href="#ventajas-y-desventajas-de-la-compilación">Ventajas y Desventajas de la Compilación</a></h2>
<h3 id="ventajas-de-la-compilación"><a class="header" href="#ventajas-de-la-compilación">Ventajas de la Compilación</a></h3>
<ol>
<li>
<p><strong>Rendimiento:</strong> Los programas compilados suelen ser más rápidos y eficientes en tiempo de ejecución porque el código se optimiza durante la compilación.</p>
</li>
<li>
<p><strong>Seguridad:</strong> El código fuente no está disponible en el programa compilado, lo que puede proteger la propiedad intelectual.</p>
</li>
<li>
<p><strong>Independencia del lenguaje fuente:</strong> Una vez compilado, el programa puede ejecutarse en cualquier plataforma que soporte el código de máquina generado.</p>
</li>
</ol>
<h3 id="desventajas-de-la-compilación"><a class="header" href="#desventajas-de-la-compilación">Desventajas de la Compilación</a></h3>
<ol>
<li>
<p><strong>Tiempo de compilación:</strong> Los programas grandes pueden llevar mucho tiempo para compilar.</p>
</li>
<li>
<p><strong>Dependencia de la plataforma:</strong> El código compilado es específico de la plataforma para la que se compiló. Si se necesita ejecutar el programa en diferentes plataformas, se debe compilar por separado para cada una.</p>
</li>
<li>
<p><strong>Dificultad para depurar:</strong> Los errores en tiempo de ejecución pueden ser más difíciles de rastrear porque el código que se está ejecutando es diferente del código fuente original.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fase-de-análisis-el-frontend-del-compilador"><a class="header" href="#fase-de-análisis-el-frontend-del-compilador">Fase de Análisis (El Frontend del Compilador)</a></h1>
<p>La fase de análisis, también conocida como frontend del compilador, es el punto de partida donde el código fuente es sometido a un exhaustivo escrutinio léxico, sintáctico y semántico. Esta fase da lugar a la creación de una representación intermedia del programa fuente y a la construcción de la tabla de símbolos, que servirán como entrada para la fase de síntesis.</p>
<p><img src="U1/U1S1/compilador/analisis/../../FasesdeunCompilador.png" alt="Fases de un Compilador" /></p>
<h2 id="subfases-de-análisis"><a class="header" href="#subfases-de-análisis">Subfases de Análisis</a></h2>
<h3 id="1-análisis-léxico"><a class="header" href="#1-análisis-léxico">1. Análisis Léxico</a></h3>
<p>El análisis léxico, la primera subfase del frontend, se encarga de garantizar que todas las palabras del código se ajusten al alfabeto del lenguaje y estén definidas dentro del mismo. Aquí, el código fuente se descompone en unidades léxicas llamadas tokens, que representan las entidades básicas del lenguaje de programación.</p>
<h3 id="2-análisis-sintáctico"><a class="header" href="#2-análisis-sintáctico">2. Análisis Sintáctico</a></h3>
<p>El análisis sintáctico verifica que cada estructura del código respete las reglas gramaticales del lenguaje, asegurando que tenga un sentido estructuralmente correcto. Este proceso se encarga de construir la estructura jerárquica del programa, utilizando la secuencia de tokens generada por el análisis léxico.</p>
<h3 id="3-análisis-semántico"><a class="header" href="#3-análisis-semántico">3. Análisis Semántico</a></h3>
<p>El análisis semántico se adentra en el significado del código, verificando que las construcciones del programa tengan coherencia semántica. Se asegura de que las variables estén correctamente declaradas, que los tipos de datos sean compatibles y que las operaciones tengan sentido en el contexto del programa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="análisis-léxico-la-puerta-de-entrada-al-compilador"><a class="header" href="#análisis-léxico-la-puerta-de-entrada-al-compilador">Análisis Léxico: La Puerta de Entrada al Compilador</a></h1>
<p>El análisis léxico representa el primer paso en el proceso de compilación, donde el programa fuente es sometido a un minucioso escrutinio para identificar sus elementos básicos y significativos. Esta fase, también conocida como frontend del compilador, desempeña un papel fundamental al transformar el código fuente en una secuencia de tokens, los cuales servirán como base para las etapas posteriores del proceso de compilación.</p>
<h2 id="proceso-de-análisis-léxico"><a class="header" href="#proceso-de-análisis-léxico">Proceso de Análisis Léxico</a></h2>
<p>El análisis léxico se desarrolla en varias etapas que garantizan una adecuada interpretación del código fuente:</p>
<ol>
<li>
<p><strong>Lectura del Programa Fuente</strong>: En esta etapa inicial, el compilador lee el programa fuente en su totalidad.</p>
</li>
<li>
<p><strong>Eliminación de Espacios en Blanco y Comentarios</strong>: Se eliminan los espacios en blanco, tabulaciones y saltos de línea para simplificar el código. Asimismo, los comentarios son descartados, ya que no son relevantes para el proceso de análisis.</p>
</li>
<li>
<p><strong>Agrupación en Tokens</strong>: Los caracteres restantes se agrupan en unidades llamadas tokens. Un token es una secuencia de caracteres que representa una unidad semántica significativa dentro del código.</p>
</li>
</ol>
<h3 id="tokens"><a class="header" href="#tokens">Tokens</a></h3>
<p>Un token es una secuencia de caracteres que forman una unidad significativa</p>
<h4 id="tipos-de-tokens"><a class="header" href="#tipos-de-tokens">Tipos de Tokens</a></h4>
<ul>
<li>
<p><strong>Palabras Reservadas</strong>: Representan instrucciones o comandos predefinidos en el lenguaje de programación, como IF, THEN, ELSE.</p>
</li>
<li>
<p><strong>Operadores</strong>: Incluyen símbolos que denotan operaciones o relaciones entre entidades, como +, &gt;=, :=.</p>
</li>
<li>
<p><strong>Identificadores</strong>: Son cadenas de caracteres que representan nombres de variables, funciones o elementos definidos por el usuario, como Plazo, Tasa.</p>
</li>
<li>
<p><strong>Constantes</strong>: Representan valores fijos, como números enteros o decimales, por ejemplo, 30, 100.</p>
</li>
</ul>
<h2 id="interacción-con-el-análisis-sintáctico"><a class="header" href="#interacción-con-el-análisis-sintáctico">Interacción con el Análisis Sintáctico</a></h2>
<p>La interacción entre el análisis léxico y el análisis sintáctico es crucial para garantizar la comprensión correcta del código. Esta interacción puede tomar varias formas:</p>
<ul>
<li>Ambas actividades se ejecutan en modo batch, procesando todo el código de una sola vez.</li>
<li>Son actividades concurrentes, lo que permite una mayor eficiencia en el análisis.</li>
<li>Ambas actividades pueden integrarse como rutinas del generador de código.</li>
<li>El análisis léxico puede ser una rutina del análisis sintáctico, proporcionando los tokens necesarios para su procesamiento.</li>
</ul>
<h2 id="ejemplo-práctico"><a class="header" href="#ejemplo-práctico">Ejemplo Práctico</a></h2>
<p>Esta tabla muestra cómo se identifican los tokens en un programa fuente.</p>
<div class="table-wrapper"><table><thead><tr><th>Token</th><th>Identificación del token</th></tr></thead><tbody>
<tr><td>ID</td><td>27</td></tr>
<tr><td>CTE</td><td>28</td></tr>
<tr><td>IF</td><td>59</td></tr>
<tr><td>THEN</td><td>60</td></tr>
<tr><td>ELSE</td><td>61</td></tr>
<tr><td>+</td><td>70</td></tr>
<tr><td>/</td><td>73</td></tr>
<tr><td>&gt;=</td><td>80</td></tr>
<tr><td>:=</td><td>85</td></tr>
</tbody></table>
</div>
<p>ID es un identificador, CTE es una constante y los demás son palabras reservadas u operadores.</p>
<p>Tomemos como ejemplo el siguiente código:</p>
<pre><code>if Plazo &gt;= 30
then Tasa := Base + Recargo / 100  
else Tasa := Base
</code></pre>
<p>Aquí, podemos observar cómo se divide en tokens:</p>
<pre><code>[IF] [Plazo] [&gt;=] [30] 
[THEN] [Tasa] [:=] [Base] [+] [Recargo] [/] [100] 
[ELSE] [Tasa] [:=] [Base]
</code></pre>
<p>Este código se convierte en una secuencia de tokens significativos para el compilador, donde cada token se asocia con una identificación única:</p>
<pre><code>[59] [27] [80] [28] 
[60] [27] [85] [27] [70] [27] [73] [28] 
[61] [27] [85] [27]
</code></pre>
<p>En este ejemplo, el token "IF" se identifica con el número [59], el identificador "Plazo" con el número [27], el operador "&gt;=" con el número [80], y así sucesivamente.</p>
<h2 id="diferencia-entre-lexema-y-token"><a class="header" href="#diferencia-entre-lexema-y-token">Diferencia entre Lexema y Token</a></h2>
<p>En el contexto del análisis léxico, es importante comprender la diferencia entre lexema y token:</p>
<ul>
<li>
<p><strong>Lexema</strong>: Es la secuencia de caracteres que representa una unidad léxica en el código fuente. Por ejemplo, en el código <code>Plazo &gt;= 30</code>, el lexema "Plazo" representa un identificador.</p>
</li>
<li>
<p><strong>Token</strong>: Es la combinación de un lexema y una identificación única que representa una unidad semántica en el código fuente. Por ejemplo, en el código <code>Plazo &gt;= 30</code>, el token asociado al lexema "Plazo" es [27], que representa un identificador.</p>
</li>
</ul>
<p>La tabla a continuación muestra algunos ejemplos de lexemas y sus correspondientes tokens:</p>
<div class="table-wrapper"><table><thead><tr><th>Lexema</th><th>Token</th></tr></thead><tbody>
<tr><td>Plazo</td><td>[27]</td></tr>
<tr><td>&gt;=</td><td>[80]</td></tr>
<tr><td>30</td><td>[28]</td></tr>
<tr><td>IF</td><td>[59]</td></tr>
<tr><td>THEN</td><td>[60]</td></tr>
<tr><td>ELSE</td><td>[61]</td></tr>
<tr><td>+</td><td>[70]</td></tr>
<tr><td>/</td><td>[73]</td></tr>
<tr><td>:=</td><td>[85]</td></tr>
</tbody></table>
</div>
<p>Otro ejemplo: En el código <code>int x = 5;</code>, <code>int</code>, <code>x</code>, <code>=</code>, <code>5</code>, y <code>;</code> son lexemas. Los tokens correspondientes podrían ser <code>palabra clave: int</code>, <code>identificador: x</code>, <code>operador de asignación: =</code>, <code>constante entera: 5</code>, y <code>punto y coma: ;</code>.</p>
<p>El lexema es la representación textual de una unidad léxica, mientras que el token es la combinación del lexema y su identificación única en el análisis léxico.</p>
<h1 id="ejercicio"><a class="header" href="#ejercicio">Ejercicio</a></h1>
<p>Toma como referencia el programa mostrado y la tabla adjunta.</p>
<pre><code>if Plazo &gt;= 30 then
    Tasa := Base + Recargo / 100
else
    Tasa := Base
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Token</th><th>Identificación del token</th></tr></thead><tbody>
<tr><td>ID</td><td>27</td></tr>
<tr><td>CTE</td><td>28</td></tr>
<tr><td>IF</td><td>59</td></tr>
<tr><td>THEN</td><td>60</td></tr>
<tr><td>ELSE</td><td>61</td></tr>
<tr><td>+</td><td>70</td></tr>
<tr><td>/</td><td>73</td></tr>
<tr><td>&gt;=</td><td>80</td></tr>
<tr><td>:=</td><td>85</td></tr>
</tbody></table>
</div>
<p>Expresare el programa en:</p>
<ol>
<li>lexemas</li>
<li>en código numérico de los tokens</li>
<li>en tokens</li>
<li>Scanner el programa indicando el número de línea, indicar si es palabra reservada, indicar el token, en los identificadores indicar el número de línea y en las constantes indicar su valor.</li>
</ol>
<h2 id="desarrollo"><a class="header" href="#desarrollo">Desarrollo</a></h2>
<ol>
<li>Lexemas:</li>
</ol>
<p>Los lexemas encontrados son:</p>
<pre><code>if, Plazo, &gt;=, 30, then, 
Tasa, :=, Base, +, Recargo, /, 100, 
else, 
Tasa, :=, Base
</code></pre>
<ol start="2">
<li>Código numérico de los tokens:</li>
</ol>
<p>Los códigos numéricos de los tokens son:</p>
<pre><code>59, 27, 80, 28, 60, 
27, 85, 27, 70, 27, 73, 28, 
61, 
27, 85, 27
</code></pre>
<ol start="3">
<li>Tokens:</li>
</ol>
<p>Los tokens son:</p>
<pre><code>[59], [27], [80], [28], [60], 
[27], [85], [27], [70], [27], [73], [28], 
[61], 
[27], [85], [27]
</code></pre>
<ol start="4">
<li>Scanner del programa por línea:</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th>Línea</th><th>Tipo</th><th>Lexema</th><th>Token</th></tr></thead><tbody>
<tr><td>1</td><td>Palabra reservada</td><td>IF</td><td>[59]</td></tr>
<tr><td>1</td><td>Identificador</td><td>Plazo</td><td>[27]</td></tr>
<tr><td>1</td><td>Operador</td><td>&gt;=</td><td>[80]</td></tr>
<tr><td>1</td><td>Constante</td><td>30</td><td>[28]</td></tr>
<tr><td>1</td><td>Palabra reservada</td><td>THEN</td><td>[60]</td></tr>
<tr><td>2</td><td>Identificador</td><td>Tasa</td><td>[27]</td></tr>
<tr><td>2</td><td>Operador</td><td>:=</td><td>[85]</td></tr>
<tr><td>2</td><td>Identificador</td><td>Base</td><td>[27]</td></tr>
<tr><td>2</td><td>Operador</td><td>+</td><td>[70]</td></tr>
<tr><td>2</td><td>Identificador</td><td>Recargo</td><td>[27]</td></tr>
<tr><td>2</td><td>Operador</td><td>/</td><td>[73]</td></tr>
<tr><td>2</td><td>Constante</td><td>100</td><td>[28]</td></tr>
<tr><td>3</td><td>Palabra reservada</td><td>ELSE</td><td>[61]</td></tr>
<tr><td>4</td><td>Identificador</td><td>Tasa</td><td>[27]</td></tr>
<tr><td>4</td><td>Operador</td><td>:=</td><td>[85]</td></tr>
<tr><td>4</td><td>Identificador</td><td>Base</td><td>[27]</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="fase-de-síntesis-el-backend-del-compilador"><a class="header" href="#fase-de-síntesis-el-backend-del-compilador">Fase de Síntesis (El Backend del Compilador)</a></h1>
<p>La fase de síntesis, también conocida como backend del compilador, es donde se genera el programa destino a partir del código fuente, su representación intermedia y la tabla de símbolos obtenida en la fase de análisis.</p>
<p><img src="U1/U1S1/compilador/sintesis/../../FasesdeunCompilador.png" alt="Fases de un Compilador" /></p>
<h2 id="subfases-de-síntesis"><a class="header" href="#subfases-de-síntesis">Subfases de Síntesis</a></h2>
<h3 id="1-generación-de-código-intermedio"><a class="header" href="#1-generación-de-código-intermedio">1. Generación de Código Intermedio</a></h3>
<p>En esta subfase, se recibe la representación intermedia del programa y se transforma en una forma más abstracta y fácil de optimizar. El código intermedio tiende a ser independiente de la máquina objetivo y facilita las etapas posteriores de optimización y generación de código objeto.</p>
<h3 id="2-optimización-de-código"><a class="header" href="#2-optimización-de-código">2. Optimización de Código</a></h3>
<p>La optimización de código se encarga de mejorar la representación intermedia del programa para que sea más eficiente en términos de tiempo de ejecución y consumo de recursos. Transforma fragmentos de código en otros equivalentes pero más eficientes, utilizando técnicas como la eliminación de código redundante o la reorganización de operaciones.</p>
<h3 id="3-generación-de-código-objeto"><a class="header" href="#3-generación-de-código-objeto">3. Generación de Código Objeto</a></h3>
<p>En la fase final, el generador de código objeto traduce la representación intermedia del programa en código ejecutable para la máquina objetivo. Este código objeto es el resultado final del proceso de compilación y puede ser ejecutado directamente por la computadora.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elementos-básicos-de-los-lenguajes-formales-alfabetos-cadenas-y-lenguajes"><a class="header" href="#elementos-básicos-de-los-lenguajes-formales-alfabetos-cadenas-y-lenguajes">Elementos Básicos de los Lenguajes Formales Alfabetos, Cadenas y Lenguajes</a></h1>
<p>Lenguajes Regulares y Fundamentos Lingüísticos</p>
<h2 id="alfabetos"><a class="header" href="#alfabetos">Alfabetos</a></h2>
<p>Un alfabeto se define como un conjunto no vacío de símbolos o caracteres. Se denota con la letra griega mayúscula Σ (sigma), y se cumple que <code>Σ ≠ ∅</code>, lo que significa que su cardinalidad <code>(|Σ|)</code> es mayor que cero.</p>
<p>Ejemplos de alfabetos:</p>
<ul>
<li>Σ = {a, b, c, ..., z}: Alfabeto del lenguaje español.</li>
<li>Σ = {0, 1, 2, ..., 9}: Alfabeto numérico.</li>
<li>Σ = {0, 1}: Alfabeto binario computacional.</li>
<li>Σ = {0, 1, ..., 9, A, B, ..., F}: Alfabeto hexadecimal.</li>
</ul>
<p>Un símbolo o carácter es un elemento perteneciente a un alfabeto dado. Por ejemplo, si <code>X ∈ Σ</code>, entonces <code>X</code> es un símbolo del alfabeto <code>Σ</code>.</p>
<h2 id="cadenas"><a class="header" href="#cadenas">Cadenas</a></h2>
<p>Las cadenas, también conocidas como palabras o strings, son yuxtaposiciones de elementos de un alfabeto. Una cadena se forma mediante la concatenación de símbolos de un alfabeto dado.</p>
<p>Ejemplos de cadenas en el alfabeto binario <code>Σ = {0, 1}</code>:</p>
<ul>
<li>W1 = 0, 1, 1, 0, 1</li>
<li>W2 = 0</li>
<li>W3 = ε (cadena vacía, representada por el símbolo épsilon)</li>
</ul>
<p>El tamaño de una cadena se determina por el número de símbolos que la componen.</p>
<p>Por ejemplo:</p>
<ul>
<li>|W1| = 5</li>
<li>|W2| = 1</li>
<li>|ε| = 0</li>
</ul>
<p>La operación de concatenación de cadenas se denota mediante la yuxtaposición de las mismas.</p>
<p>Si <code>X = a1, a2, ..., an y Y = b1, b2, ..., bm</code>, entonces la concatenación de <code>X</code> e <code>Y</code> se representa como <code>XY = a1, a2, ..., an, b1, b2, ..., bm</code>.</p>
<p>Se pueden definir operaciones sobre conjuntos de cadenas, como la clausura de Kleene <code>(Σ*)</code> y la clausura de Kleene positiva <code>(Σ+)</code>. La clausura de Kleene de un alfabeto <code>Σ</code> se define como <code>Σ* = Σ0 ∪ Σ1 ∪ Σ2 ∪ ...</code>, donde <code>Σ0 = {ε}</code> y <code>Σn</code> representa todas las cadenas de longitud <code>n</code> formadas con símbolos de <code>Σ</code>. Por otro lado, la clausura de Kleene positiva excluye la cadena vacía: <code>Σ+ = Σ* - {ε}</code>.</p>
<h2 id="lenguajes"><a class="header" href="#lenguajes">Lenguajes</a></h2>
<p>Un lenguaje sobre un alfabeto <code>Σ</code> es cualquier subconjunto de la clausura de Kleene de ese alfabeto <code>(Σ*)</code>. Se denota como <code>L ⊆ Σ*</code>. Por ejemplo, el lenguaje español es un subconjunto de todas las combinaciones posibles del alfabeto formado por las letras seria <strong>[A-Za-zñÑ]</strong>.</p>
<p>Es posible realizar operaciones sobre los lenguajes, como la concatenación. Si <strong>L1</strong> y <strong>L2</strong> son lenguajes, su concatenación se define como <code>L1L2 = {XY | X ∈ L1, Y ∈ L2}</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lenguaje-regular"><a class="header" href="#lenguaje-regular">Lenguaje Regular</a></h1>
<h2 id="introducción"><a class="header" href="#introducción">Introducción</a></h2>
<p>Los lenguajes regulares son ampliamente utilizados en el procesamiento de lenguajes de programación y en la búsqueda de cadenas de caracteres o secuencias específicas. Las expresiones regulares (E.R) proporcionan una manera sencilla de describir estas secuencias de caracteres. La búsqueda de caracteres o secuencias concretas de caracteres en documentos forma parte de las tareas estándar y recurrentes de la tecnología de la información. Por lo general, el objetivo es modificar o sustituir fragmentos de texto o líneas de código, cuya complejidad aumenta en función de las veces que la secuencia de caracteres aparece en el documento.</p>
<h2 id="lenguaje-regular-1"><a class="header" href="#lenguaje-regular-1">Lenguaje Regular</a></h2>
<p>Un <strong>lenguaje regular</strong> es una secuencia de elementos que cumple y verifica las siguientes condiciones:</p>
<ul>
<li><code>a ∈ V</code> entonces <code>a</code> es una E.R. (donde <code>V</code> es un alfabeto)</li>
<li>Si <code>X</code> e <code>Y</code> son E.R., entonces <code>X.Y</code> es una E.R. (parte recursiva)</li>
<li>Si <code>X</code> e <code>Y</code> son E.R., entonces <code>X+Y</code> es una E.R. (concatenación)</li>
<li>Si <code>X</code> es una E.R., entonces <code>X*</code> es una E.R. (clausura de cualquier E.R. es una E.R.)</li>
</ul>
<p>Esta definición indica que las expresiones regulares pueden contener:</p>
<ul>
<li>Letras del alfabeto que forman palabras.</li>
<li>Concatenaciones, sumas, multiplicaciones y clausuras.</li>
<li>La cadena vacía <code>λ</code> (lambda).</li>
</ul>
<p><strong>Ejemplo 1:</strong></p>
<p>Si <code>V = {a, b, c}</code>, algunas de las expresiones regulares que se pueden formar con este alfabeto son:</p>
<pre><code>a + b*
(a + c)b
a*c*
a*(b + c)c
b(a + λ)
</code></pre>
<p><strong>Ejemplo 2:</strong></p>
<p>La expresión regular del lenguaje cuyas palabras están formadas por las letras del alfabeto <code>V = {a, b}</code> y terminan en <code>"b"</code> es:</p>
<pre><code>(a + b)*b
</code></pre>
<p><strong>Ejemplo 3:</strong></p>
<p>La expresión regular del lenguaje cuyas palabras están formadas por las letras del alfabeto <code>V = {a, b}</code>, tienen longitud mayor a 2, la segunda letra es <code>"a"</code>, y la antepenúltima es <code>"b"</code>, es:</p>
<pre><code>(a + b)a(a + b)*b(a + b)
</code></pre>
<p>Esta expresión regular se puede interpretar de la siguiente manera:</p>
<ol>
<li>La primera letra puede ser <code>a</code> o <code>b</code>.</li>
<li>Luego sigue obligatoriamente una <code>a</code>.</li>
<li>Después, puede haber cualquier secuencia de <code>a</code> o <code>b</code> de cualquier longitud.</li>
<li>Posteriormente, viene una <code>b</code>.</li>
<li>Finalmente, una <code>a</code> o <code>b</code>.</li>
</ol>
<p><strong>Ejemplo 4:</strong> La expresión regular del lenguaje cuyas palabras están formadas por las letras del alfabeto <code>V = {a, b}</code> y consisten en 3 o más letras <code>"b"</code> seguidas de una letra <code>"a"</code>, es:</p>
<pre><code>bbb*a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expresiones-regulares-para-tokens-de-lenguajes-de-programación-1"><a class="header" href="#expresiones-regulares-para-tokens-de-lenguajes-de-programación-1">Expresiones regulares para tokens de lenguajes de programación</a></h1>
<h2 id="1-expresiones-regulares-para-tokens-de-lenguajes-de-programación"><a class="header" href="#1-expresiones-regulares-para-tokens-de-lenguajes-de-programación">1. Expresiones Regulares para Tokens de Lenguajes de Programación</a></h2>
<ul>
<li>Palabras Reservadas</li>
<li>Símbolos Especiales</li>
<li>Identificadores</li>
<li>Literales o Constantes</li>
</ul>
<h2 id="2-expresiones-regulares-para-números"><a class="header" href="#2-expresiones-regulares-para-números">2. Expresiones Regulares para Números</a></h2>
<ul>
<li>Números Enteros con Signo y sin Signo</li>
<li>Números Reales con Signo y sin Signo</li>
<li>Números Reales en Notación Punto Flotante</li>
</ul>
<h2 id="3-expresiones-regulares-para-identificadores"><a class="header" href="#3-expresiones-regulares-para-identificadores">3. Expresiones Regulares para Identificadores</a></h2>
<ul>
<li>Definición y Ejemplos de Identificadores en un Lenguaje de Programación</li>
<li>Expresión Regular para Identificadores</li>
</ul>
<h2 id="4-expresiones-regulares-para-tokens-específicos"><a class="header" href="#4-expresiones-regulares-para-tokens-específicos">4. Expresiones Regulares para Tokens Específicos</a></h2>
<ul>
<li>Ejemplos de Expresiones Regulares para Tokens de un Lenguaje de Programación</li>
<li>Conjunto de Tokens del Analizador Léxico, como:
<ul>
<li>IF</li>
<li>THEN</li>
<li>ELSE</li>
<li>PLUS</li>
<li>MINUS</li>
<li>TIMES</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autómatas-autómatas-finitos-deterministas-dfa"><a class="header" href="#autómatas-autómatas-finitos-deterministas-dfa">Autómatas. Autómatas finitos deterministas (DFA)</a></h1>
<h2 id="1-autómatas"><a class="header" href="#1-autómatas">1. Autómatas</a></h2>
<ul>
<li>Introducción a los Autómatas</li>
<li>Autómatas Finitos Deterministas (DFA)
<ul>
<li>Definición y Características</li>
<li>Estados, Estado Inicial, Estados Finales</li>
<li>Tabla y Diagrama de un Autómata Finito</li>
</ul>
</li>
</ul>
<h2 id="2-lenguaje-reconocido-por-un-autómata-finito-determinista"><a class="header" href="#2-lenguaje-reconocido-por-un-autómata-finito-determinista">2. Lenguaje Reconocido por un Autómata Finito Determinista</a></h2>
<ul>
<li>Definición del Lenguaje Reconocido</li>
<li>Proceso de Reconocimiento de Cadenas</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-2-autómatas-deterministas-y-autómatas-no-deterministas"><a class="header" href="#unidad-2-autómatas-deterministas-y-autómatas-no-deterministas">Unidad 2: Autómatas deterministas y autómatas no deterministas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="definición-de-un-autómata-finito-no-determinista-nfa"><a class="header" href="#definición-de-un-autómata-finito-no-determinista-nfa">Definición de un Autómata Finito no determinista (NFA)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ejemplos-de-la-relación-de-expresiones-regulares-lenguajes-regulares-y-los-autómatas"><a class="header" href="#ejemplos-de-la-relación-de-expresiones-regulares-lenguajes-regulares-y-los-autómatas">Ejemplos de la relación de expresiones regulares, lenguajes regulares y los autómatas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teorema-de-kleene-un-lenguaje-es-regular-si-y-solo-si-es-reconocido-por-un-autómata-finito"><a class="header" href="#teorema-de-kleene-un-lenguaje-es-regular-si-y-solo-si-es-reconocido-por-un-autómata-finito">Teorema de Kleene: Un Lenguaje es regular si y solo si es reconocido por un autómata finito</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teorema-si-un-lenguaje-es-reconocido-por-un-autómata-finito-no-determinista-entonces-dicho-lenguaje-también-es-reconocido-por-un-autómata-finito-determinista"><a class="header" href="#teorema-si-un-lenguaje-es-reconocido-por-un-autómata-finito-no-determinista-entonces-dicho-lenguaje-también-es-reconocido-por-un-autómata-finito-determinista">Teorema: Si un lenguaje es reconocido por un autómata finito no determinista entonces dicho lenguaje también es reconocido por un autómata finito determinista</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversión-de-af-no-determinista-en-determinístico-por-el-algoritmo-de-la-construcción-de-sub-conjuntos"><a class="header" href="#conversión-de-af-no-determinista-en-determinístico-por-el-algoritmo-de-la-construcción-de-sub-conjuntos">Conversión de AF no determinista en Determinístico por el algoritmo de la construcción de sub-conjuntos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-3-manejo-de-la-herramienta-flex"><a class="header" href="#unidad-3-manejo-de-la-herramienta-flex">Unidad 3: Manejo de la herramienta Flex</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flex-una-herramienta-para-generar-analizadores-léxicos"><a class="header" href="#flex-una-herramienta-para-generar-analizadores-léxicos">FLEX una herramienta para generar analizadores léxicos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-formato-de-un-archivo-de-entrada-de-flex"><a class="header" href="#el-formato-de-un-archivo-de-entrada-de-flex">El formato de un archivo de entrada de FLEX</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uso-del-flex-para-diferentes-tareas"><a class="header" href="#uso-del-flex-para-diferentes-tareas">Uso del FLEX para diferentes tareas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilización-del-flex-para-otras-tareas"><a class="header" href="#utilización-del-flex-para-otras-tareas">Utilización del FLEX para otras tareas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uso-del-flex-para-generar-un-analizador-léxico"><a class="header" href="#uso-del-flex-para-generar-un-analizador-léxico">Uso del Flex para generar un analizador léxico</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unidad-4-definición-formal-de-una-gramática"><a class="header" href="#unidad-4-definición-formal-de-una-gramática">Unidad 4: Definición formal de una gramática</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="máquinas-de-estados-finitos"><a class="header" href="#máquinas-de-estados-finitos">Máquinas de Estados Finitos</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="máquina-de-estado-finito-para-diferentes-aplicaciones"><a class="header" href="#máquina-de-estado-finito-para-diferentes-aplicaciones">Máquina de estado finito para diferentes aplicaciones</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluación-final-individual"><a class="header" href="#evaluación-final-individual">Evaluación final individual</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
